
/**
  * A ``table'' at which the dining philosophers eat and think.
  *
  * @author Stephen J. Hartley
  * @version 2005 July
  */
monitor class DiningServerImpl extends DiningServer {
 
  /**
    * Constructor.
    * @param numPhils The number of dining philosophers.
    */
  private DiningServerImpl(int numPhils) {
    super(numPhils);
  }

  /**
    * Factory method.
    * @param numPhils The number of dining philosophers.
    * @return A dining server table object.
    */
  public static DiningServer newInstance(int numPhils) {
    DiningServer instance = new DiningServerImpl(numPhils);
    return instance;
  }

  /**
    * Test the availability of the two forks for a hungry philosopher.
    * If available, set the state of the hungry philosopher to eating.
    * @param k The number of the hungry philosopher.
    */
  private void test(int k) {
    if (state[left(k)] != State.EATING && state[k] == State.HUNGRY &&
          state[right(k)] != State.EATING) {
       state[k] = State.EATING;
    }
  }

  /**
    * A hungry philosopher attempts to pick up its two forks.  If available,
    * the philosopher eats, else waits.
    * @param i The number of the hungry philosopher.
    * @throws InterruptedException
    */
  protected void takeForks(int i) throws InterruptedException {
    state[i] = State.HUNGRY;
    printState("begin takeForks");
    test(i);
    printState("end   takeForks");
    await(state[i] != State.EATING);
  }

  /**
    * A philosopher has finished eating.  Return its two forks to the table
    * and check for hungry neighbors.  If a hungry neighbor's two forks
    * are now available, nudge the neighbor.
    * @param i The number of the philosopher finished eating.
    */
  protected void putForks(int i) {
    if (state[i] != State.EATING) return;
    state[i] = State.THINKING;
    printState("begin  putForks");
    test(left(i));  test(right(i));
    printState("end    putForks");
  }
}
